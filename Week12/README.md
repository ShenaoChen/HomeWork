# code 1：319.灯泡开关
**思路：** 每一个灯泡的开关情况会被它的每一个因数切换一次，而每一个非完全平方数都有偶数个因数，每一个完全平方数都有偶数个因数而开关状态切换奇数次最终状态为亮，切换偶数次最终状态为灭，所以只需要求出1-n中完全平方数的个数即可。

# code 2：391.完美矩形

**思路：** 所有的小矩形可以完美拼接为一个大矩形当且仅当只有大矩形的四个顶点出现一次，且其余顶点不出现三次，并且所有小矩形的面积之和要等于大矩形的面积。面积的判断很容易实现。对于顶点出现的次数，我们可以用哈希表或平衡树来维护每一个顶点出现的次数，在读入每一个小矩形时，将这个小矩形的四个顶点出现的次数加1，最终遍历哈希表或平衡树来判断是否满足条件。

# code 3：318. 最大单词长度乘积

**思路：** 状态压缩，对于每一个用一个三十二位整数来表示a-z有没有出现过，对于两个字符串对状态压缩后的整数做按位与操作，结果为0则表示两个字符串没有重复的字母，否则表示有相同的字母出现过。可以两重循环遍历字符串数组，对于每次取到的两个字符串判断是否有相同字母，如果没有则计算当前两个字符串长度的乘积，并更新最大值。

# code 4：563.二叉树的坡度

**思路：** 计算二叉树的坡度需要知道左右子树的节点个数，我们可以用后续遍历来求每个节点的左右子树的节点个数，在每次递归返回前，先用左右子树的节点个数更新答案即可。



# code 5：397.整数替换

**思路：** 广搜求最短路径，对于偶数则将 $$\frac n 2$$ 放入队列，对于奇数则将 $$n+1和n-1$$ 分别放入队列，直到搜索到1为止。



# code 6：594.最长和谐子序列

## 方法一排序加双指针

**思路：** 由于和谐数组只与数组中的最大和最小值有关，而与数组的顺序无关，我们可以先对数组做排序，然后使用双指针算法来遍历整个数组得到答案。

**时间复杂度：** 排序$$O(n\ log\ n)$$，双指针$$O(n)$$，总复杂度$$O(n\ log\ n)$$。

**空间复杂度：**$$O(1)$$。



## 方法二哈希表

**思路：** 我们可以用一个哈希表来存每一个数出现的次数，然后遍历整个哈希表，如果当前数加一也在哈希表中，我们就用答案和当前数的个数与当前数加一的个数更新答案。

**时间复杂度：**$$O(n)$$，需要线性复杂度扫描数组，也需要线性复杂度扫描哈希表。

**空间复杂度：**$$O(n)$$，需要存储哈希表。



# code 7：599.N叉树的最大深度

**思路：** 一个常规的求树高的题目，深搜遍历整棵树，记录所有子树中最高的树高，返回该树高加一即可.



